'use strict';

var uuid = require('node-uuid');
var Datastore = require('nedb');
var WordList = require('../src/wordlist');
var HangManager = require('../src/manager');
var path = require('path');

var FILE_DB_EXT = '.json';
var DEFAULT_DB_PATH = path.join('db', '/datafile' + FILE_DB_EXT);

/**
 * Expire games after 24 hours.
 */
var RECORD_TTL = 60 * 60 * 60 * 24;

var db = new Datastore({
  timestampData: true,
  //inMemoryOnly: true,
  autoload: true,
  filename: DEFAULT_DB_PATH
});

// Set an index against the ID field in each record, which is separate from
// the _id field used by the database. The ID is generated by this Manager
// when creating a new game.
db.ensureIndex({
  fieldName: 'game_id',

  // Ensure all set IDs are unique
  unique: true,

  // Fallback check--only allow records to be written that have this index
  sparse: true,

  // For clean up purposes, expire records after RECORD_TTL seconds
  expireAfterSeconds: RECORD_TTL
});

// Create a new HangManager for handling business logic and database
// interactions
var hangManager = new HangManager({
  db: db
});

/**
 * General method for handling errors from the service. Any 5XX error is logged
 * out for debugging purposes before being sent to the client.
 * </p>
 * <p>
 * All errors passed to this method should include the status code of the
 * error, and a user-friendly message indicating the error.
 * </p>
 * <p>
 * <strong>NOTE</strong>: This method closes the response object on completion.
 * </p>
 *
 * @param res (object) the response object
 * @param err (object) the error object returned from the service for an
 *                     internal error during runtime
 */
var handleError = function(res, err) {
  if (err.code >= 500) {
    console.log('Returning 5XX response to the client: ' + JSON.stringify(err, null, 2));
  }
  res.writeHead(err.code, { 'Content-Type': 'application/json' });

  var responseContent = {
    error: err.message
  };
  res.write(JSON.stringify(responseContent, null, 2));
  res.end();
};

exports.createGame = function(args, res, next) {
  try {
    hangManager.createGame(function(err, game) {
      if (err) {
        handleError(res, err);
      } else {
        res.writeHead(201, {
          'Content-Type': 'application/json',
          'Location': '/hangman/' + game.game_id
        });
        res.write(JSON.stringify(game, null, 2));
        res.end();
      }
    });
  } catch (e) {
    handleError(res, {
      code: 500,
      message: e.message,
      err: e
    });
  }
};

exports.deleteGame = function(args, res, next) {
  try {
    hangManager.deleteGame(args.game_id.value, function(err) {
      if (err) {
        handleError(res, err);
      } else {
        res.writeHead(200);
        res.end();
      }
    });
  } catch (e) {
    handleError(res, {
      code: 500,
      message: e.message,
      err: e
    });
  }
};

exports.getGame = function(args, res, next) {
  try {
    hangManager.getGame(args.game_id.value, function(err, game) {
      if (err) {
        handleError(res, err);
      } else {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.write(JSON.stringify(game, null, 2));
        res.end();
      }
    });
  } catch (e) {
    handleError(res, {
      code: 500,
      message: e.message,
      err: e
    });
  }
};

exports.guessLetter = function(args, res, next) {
  try {
    var game_id = args.game_id.value;
    var body = args.content.value;

    if (!game_id) {
      handleError(res, {
        code: 400,
        message: 'Missing game ID in request path'
      });
    } else if (!body || !body.guess) {
      handleError(res, {
        code: 400,
        message: 'Missing body or "guess" property of body'
      });
    } else {
      hangManager.guessLetter(game_id, body.guess, function(err, game) {
        if (err) {
          handleError(res, err);
        } else {
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.write(JSON.stringify(game, null, 2));
          res.end();
        }
      });
    }
  } catch (e) {
    handleError(res, {
      code: 500,
      message: e.message,
      err: e
    });
  }
};
